ğŸ“Œ RxJS nima?

RxJS (Reactive Extensions for JavaScript)
bu asinxron va hodisalar oqimi (event streams) bilan ishlashni osonlashtiradigan kutubxona.

Oddiy JSâ€™da callback yoki Promise ishlatamiz.

RxJS esa Observable degan yangi tushuncha beradi:

ğŸ‘‰ Observable -> bu vaqt davomida keladigan koâ€˜plab qiymatlarni kuzatish imkonini beradi.

Masalan:

Promise â†’ faqat bitta natija qaytaradi.

Observable nima?

Observable â€” bu maâ€™lumot oqimini (stream) ifodalovchi obyekt.

U vaqt davomida 0, 1 yoki cheksiz qiymat yuborishi mumkin.

Observableâ€™ni olish uchun subscribe qilinadi.

Observable â†’ cheksiz oqim boâ€˜lishi mumkin (masalan, chat xabarlari, tugma bosilishi, real-time API).

import { Observable } from 'rxjs';

const observable = new Observable(subscriber => {
  subscriber.next("1-qiymat");
  subscriber.next("2-qiymat");
  setTimeout(() => {
    subscriber.next("3-qiymat (kechikib keldi)");
    subscriber.complete(); // oqim tugadi
  }, 2000);
});

observable.subscribe({
  next: (data) => console.log("Keldi:", data),
  complete: () => console.log("Oqim tugadi")
});
Bu radio signalga oâ€˜xshaydi: signal yuboriladi, sen uni tinglaysan.


ğŸ“Œ RxJS qayerda ishlatiladi?

1. Angular ichida

Angular frameworkâ€™da HttpClient Observable qaytaradi, shuning uchun RxJS majburiy boâ€˜ladi.

this.http.get('https://api.example.com/users')
  .subscribe(data => {
    console.log(data);
  });


2. Eventlarni boshqarishda

DOM eventlarni kuzatishda:


import { fromEvent } from 'rxjs';

fromEvent(document, 'click')
  .subscribe(() => console.log('Klik boâ€˜ldi!'));


3. Formalar bilan ishlashda

Reactive formalarda valueChanges Observable boâ€˜ladi:

this.form.get('email')?.valueChanges
  .subscribe(value => console.log('Email oâ€˜zgardi:', value));


4. Real-time ilovalarda

Chat dasturlari (xabarlar oqimi)
Online oâ€˜yinlar (real-time voqealar)
Sensor maâ€™lumotlari (IoT, live data streaming)


5. Maâ€™lumotlarni transformatsiya qilishda

RxJSâ€™da juda koâ€˜p operatorlar bor (map, filter, debounceTime, mergeMap va boshqalar) â€” ular oqimni boshqaradi.


import { from } from 'rxjs';
import { map, filter } from 'rxjs/operators';

from([1, 2, 3, 4, 5])
  .pipe(
    filter(num => num % 2 === 0),
    map(num => num * 10)
  )
  .subscribe(result => console.log(result));
// Natija: 20, 40


ğŸ“Œ Nima uchun RxJS kerak?

Asinxron kodni boshqarish oson boâ€˜ladi (callback hell yoâ€˜qoladi).
Koâ€˜p oqimlarni birlashtirish mumkin (masalan, bir nechta API soâ€˜rovlarini ketma-ket yoki parallel boshqarish).
Eventlarni boshqarish qulay (kliklar, form inputlari, WebSocket maâ€™lumotlari).
Real-time ilovalar yaratish uchun juda kuchli vosita.



3ï¸âƒ£ Operators nima?

Operators â€” bu oqimdagi maâ€™lumotlarni transformatsiya, filterlash, kombinatsiya
qilish uchun ishlatiladigan funksiyalar.

Ular .pipe() ichida qoâ€˜llanadi.

Eng mashhur operatorlar:

map â†’ qiymatni oâ€˜zgartiradi.
filter â†’ shartga mos boâ€˜lganlarini oâ€˜tkazadi
take â†’ faqat bir necha qiymatni oladi.
debounceTime â†’ foydalanuvchi yozib boâ€˜lgach kutadi.
switchMap â†’ yangi oqimga oâ€˜tadi, eski oqimni bekor qiladi.

import { from } from 'rxjs';
import { filter, map } from 'rxjs/operators';

from([1, 2, 3, 4, 5, 6])
  .pipe(
    filter(n => n % 2 === 0), // faqat juftlar
    map(n => n * 10)          // har birini 10 ga koâ€˜paytirish
  )
  .subscribe(result => console.log("Natija:", result));

Natija

Natija: 20
Natija: 40
Natija: 60


1ï¸âƒ£ tap()

tap â€” bu oqimdagi qiymatlarni oâ€˜zgartirmasdan, yon taâ€™sir (side effect)
 bajarish uchun ishlatiladigan operator.

U odatda

console.log qilish,
Debug qilish,
Qoâ€˜shimcha funksiya chaqirish uchun ishlatiladi.

Muhim: tap oqimdagi qiymatni oâ€˜zgartirmaydi, faqat â€œorasida kuzatib oâ€˜tadiâ€.

import { of } from 'rxjs';
import { tap, map } from 'rxjs/operators';

of(1, 2, 3, 4)
  .pipe(
    tap(x => console.log('Kelgan qiymat:', x)), // faqat console.log
    map(x => x * 10) // qiymatni oâ€˜zgartirish
  )
  .subscribe(result => console.log("Natija:", result));

Natija

Kelgan qiymat: 1
Natija: 10
Kelgan qiymat: 2
Natija: 20
Kelgan qiymat: 3
Natija: 30
Kelgan qiymat: 4
Natija: 40


2ï¸âƒ£ shareReplay()

shareReplay â€” bu oqimni boâ€˜lishish va kechiktirib ulanish (caching) uchun ishlatiladigan operator.

U nima qiladi?

Observable bitta marta ishlaydi, lekin bir nechta subscriber buni qayta-qayta ishlatishi mumkin.
Oxirgi N ta qiymatni eslab qoladi va yangi subscriber kelganda ularni darhol beradi.

Asosan ishlatiladi:

HttpClient soâ€˜rovlarini qayta yubormaslik uchun.
Bir nechta subscriber bitta oqimni ishlatishi kerak boâ€˜lsa.

Misol (caching API):

import { of } from 'rxjs';
import { delay, shareReplay } from 'rxjs/operators';

const apiCall$ = of("Serverdan data")
  .pipe(
    delay(2000),       // API kechikishi
    shareReplay(1)     // Oxirgi 1 qiymatni cache qiladi
  );

// 1-subscriber
apiCall$.subscribe(data => console.log("Subscriber 1:", data));

// 2 sekunddan keyin 2-subscriber
setTimeout(() => {
  apiCall$.subscribe(data => console.log("Subscriber 2:", data));
}, 3000);

Natija:


(2 sekundan keyin)
Subscriber 1: Serverdan data
Subscriber 2: Serverdan data   (yana 2 sekund kutmaydi!)

Xulosa:

tap â†’ Yon taâ€™sirlar uchun (console.log, analytics, debugging). Oqim qiymatini oâ€˜zgartirmaydi.
shareReplay â†’ Oqimni bir nechta subscriber bilan ulashadi va oxirgi qiymatlarni eslab qoladi (API caching).




4ï¸âƒ£ Subject nima?

Subject â€” bu Observable + Observer aralashmasi.

U ham maâ€™lumot yuboruvchi (producer), ham qabul qiluvchi (consumer).

Observableâ€™dan farqi: bir nechta subscriber bir xil oqimni oladi (broadcast).


import { Subject } from 'rxjs';

const subject = new Subject<number>();

// 2 ta subscriber
subject.subscribe(value => console.log("Subscriber 1:", value));
subject.subscribe(value => console.log("Subscriber 2:", value));

// Maâ€™lumot yuborish
subject.next(100);
subject.next(200);

Natija:

Subscriber 1: 100
Subscriber 2: 100
Subscriber 1: 200
Subscriber 2: 200

Oddiy Observableâ€™da har bir subscriber alohida oqim oladi, Subjectâ€™da esa hamma bir xil oqimni oladi.



Xulosa:

RxJS â†’ reaktiv dasturlash kutubxonasi, oqimlar bilan ishlash uchun.
Observable â†’ oqimni ifodalaydi, subscribe orqali maâ€™lumot olinadi.
Operators â†’ oqimni boshqarish va oâ€˜zgartirish imkonini beradi.
Subject â†’ broadcast qiluvchi oqim, bir nechta kuzatuvchilar bilan ishlaydi.



Subject va uning turlari:

Subject: Observable ham, Observer ham â€” .next() qilsa barcha subscriberâ€™larga yuboradi (broadcast).

1ï¸âƒ£ Subject ->

Oddiy Subject â€” bu Observable + Observer aralashmasi.
Har bir subscriber faqat undan keyin keladigan qiymatlarni oladi.
Oldin yuborilgan qiymatlar yangi subscriberâ€™ga berilmaydi.


import { Subject } from 'rxjs';

const subject = new Subject<number>();

subject.subscribe(v => console.log("Subscriber 1:", v));

subject.next(1);
subject.next(2);

subject.subscribe(v => console.log("Subscriber 2:", v));

subject.next(3);

ğŸ‘‰ Natija:

Subscriber 1: 1
Subscriber 1: 2
Subscriber 1: 3
Subscriber 2: 3

faqat keyingi qiymatlarni beradi.


BehaviorSubject: boshlangâ€˜ich qiymatga ega, yangi subscriber oxirgi qiymatni oladi.

2ï¸âƒ£ BehaviorSubject ->

BehaviorSubject â€” bu oxirgi qiymatni eslab qoladigan Subject.
Yangi subscriber kelganda darhol oxirgi qiymatni beradi.
Har doim biron-bir qiymatga ega boâ€˜lishi kerak (default qiymat bilan boshlanadi).


import { BehaviorSubject } from 'rxjs';

const behavior = new BehaviorSubject<number>(0); // boshlang'ich qiymat 0

behavior.subscribe(v => console.log("Subscriber 1:", v));

behavior.next(1);
behavior.next(2);

behavior.subscribe(v => console.log("Subscriber 2:", v));

behavior.next(3);

ğŸ‘‰ Natija:

Subscriber 1: 0
Subscriber 1: 1
Subscriber 1: 2
Subscriber 2: 2
Subscriber 1: 3
Subscriber 2: 3

yangi subscriber oxirgi qiymatni koâ€˜radi.



ReplaySubject: oxirgi N yoki vaqt boâ€˜yicha qiymatlarni saqlaydi va yangi subscriberâ€™ga qaytaradi.

3ï¸âƒ£ ReplaySubject ->

ğŸ‘‰ ReplaySubject â€” bu N ta eski qiymatni eslab qoladigan Subject.
Yangi subscriber kelganda oxirgi N ta qiymatni qayta oâ€˜ynaydi (replay).

import { ReplaySubject } from 'rxjs';

const replay = new ReplaySubject<number>(2); // oxirgi 2 ta qiymatni saqlaydi

replay.subscribe(v => console.log("Subscriber 1:", v));

replay.next(1);
replay.next(2);
replay.next(3);

replay.subscribe(v => console.log("Subscriber 2:", v));

replay.next(4);

ğŸ‘‰ Natija:


Subscriber 1: 1
Subscriber 1: 2
Subscriber 1: 3
Subscriber 2: 2
Subscriber 2: 3
Subscriber 1: 4
Subscriber 2: 4

yangi subscriber oxirgi N qiymatni oladi.


AsyncSubject: faqat complete() qilingach, oxirgi qiymatni tarqatadi.

4ï¸âƒ£ AsyncSubject ->

ğŸ‘‰ AsyncSubject â€” bu faqat oxirgi qiymatni oqim tugaganda (complete()) beradi.
next chaqirilgan qiymatlar saqlanadi, lekin subscriberâ€™ga berilmaydi.
Faqat complete() boâ€˜lganda oxirgi qiymat chiqariladi.

import { AsyncSubject } from 'rxjs';

const asyncSub = new AsyncSubject<number>();

asyncSub.subscribe(v => console.log("Subscriber 1:", v));

asyncSub.next(1);
asyncSub.next(2);
asyncSub.next(3);

asyncSub.subscribe(v => console.log("Subscriber 2:", v));

asyncSub.complete(); // endi chiqaradi

ğŸ‘‰ Natija:

Subscriber 1: 3
Subscriber 2: 3

faqat oxirgi qiymatni oqim tugaganda beradi.


1ï¸âƒ£ Flattening operatorlari:

1ï¸âƒ£ mergeMap ->

Har bir ichki Observableâ€™ni parallel ravishda ishga tushiradi.
Hech qaysi oqimni bekor qilmaydi, hammasini birlashtirib yuboradi.


import { of } from 'rxjs';
import { mergeMap, delay } from 'rxjs/operators';

of(1, 2, 3)
  .pipe(
    mergeMap(x => of(`Qiymat ${x}`).pipe(delay(1000)))
  )
  .subscribe(console.log);

Natija (hammasi bitta vaqtda tugaydi, tartib kafolatlanmagan):

Qiymat 1
Qiymat 2
Qiymat 3


2ï¸âƒ£ concatMap ->

Har bir oqimni navbat bilan ishlatadi.
Bittasi tugamaguncha keyingisini boshlamaydi.

of(1, 2, 3)
  .pipe(
    concatMap(x => of(`Qiymat ${x}`).pipe(delay(1000)))
  )
  .subscribe(console.log);

Natija (tartib saqlanadi, ketma-ket ishlaydi):

Qiymat 1
Qiymat 2
Qiymat 3


3ï¸âƒ£ switchMap ->

Yangi oqim kelganda eski oqimni bekor qiladi.
Faqat oxirgi soâ€˜rovning natijasini oladi.

import { interval } from 'rxjs';
import { switchMap, take } from 'rxjs/operators';

interval(1000).pipe(
  take(3),
  switchMap(x => of(`Soâ€˜rov: ${x}`).pipe(delay(1500)))
).subscribe(console.log);

Natija: faqat eng oxirgi observable natijasi chiqadi.


4ï¸âƒ£ exhaustMap ->

Agar oqim ishlayotgan boâ€˜lsa, yangi kelganlarini eâ€™tiborsiz qoldiradi.
Faqat bitta oqim ishlashi mumkin.

import { interval } from 'rxjs';
import { exhaustMap, take } from 'rxjs/operators';

interval(500).pipe(
  take(5),
  exhaustMap(x => of(`Soâ€˜rov: ${x}`).pipe(delay(1000)))
).subscribe(console.log);

Natija: Faqat birinchi kelganini bajaradi, qolganlari bekor qilinadi.